## 链表

### 定义：

链表由一系列不必在内存中相连的结构组成。每一个结构均含有表元素和指向包含该元素后继元的结构的指针。我们称之为Next指针。最后一个单元的Next指针指向NULL；该值由C定义并且不能与其他指针混淆。ANSI C规定NULL为零。

### 哑元：

上面的描述实际上足以使每一部分都能正常工作，但还是有几处地方可能会出问题。

- 第一，并不存在从所给定义出发在表的起始段插入元素的真正线性的方法。

- 第二，从表的起始段实行删除是一个特殊情况，因为改变了表的起始段，编程中的疏忽将会造成表的丢失。

- 第三个问题涉及一般的删除。虽然上述指针的移动很简单，但是删除算法要求我们记住被删除元素前面的表元。

  事实上，稍微做一个简单的变化就能够解决上述三个问题。我们可以留出一个标志节点，有时候称之为表头（header）或者哑节点（dummy node）。

### 链表基本功能实现：

**创建**

```c
Position Creat(int n) {
	Position head, node, end;
	head = malloc(sizeof(struct Node));
	end = head;
	printf("%d\n", head->Element);
	for (int i = 0; i < n; i++) {
		node = malloc(sizeof(struct Node));
		node->Element = i;
		end->Next = node;
		end = node;
	}
	end->Next = NULL;
	return head;
}
```



**打印**

```c
void Show(List L) {
	Position node;
	node = L->Next;
	while (node != NULL) {
		printf("%d\n", node->Element);
		node = node->Next;
	}
}
```



查找

```c
Position Find(int X, List L) {//查找
	Position P;
	P = L->Next;
	while (P != NULL && P->Element != X)
		P = P->Next;
	return P;
}
```



**插入**

```c
void Insert(int X, List L, Position P) {//插入操作（插入到P的后面）
	Position TmpCell;
	TmpCell = malloc(sizeof(struct Node));
	if (TmpCell == NULL)//节点申请失败
		FatalError("Out of space!!!");
	TmpCell->Element = X;
	TmpCell->Next = P->Next;
	P->Next = TmpCell;
}
```



**删除**

```c
void Delete(int X, List L) {
	Position P, TmpCell;
	P = FindPrevious(X, L);
	if (!IsLast(P, L)) {
		TmpCell = P->Next;
		P->Next = TmpCell->Next;
		free(TmpCell);
	}
}
```



### 双链表

在链表的基础上再增加一个域，使它包含指向前一个单元的指针即可

### 循环链表

让最后的单元反过来直指第一个单元。它可以有表头也可以没有，并且还可以是双向链表。



## 栈（后进先出LIFO）

### 定义

栈是限制插入和删除只能再一个位置上进行的表，该位置是表的末端，叫做栈的顶（top）。

对栈的基本操作有Push（进栈）和Pop（出栈），前者相当于插入，后者则是删除最后插入的元素。

栈顶元素是唯一可见元素。