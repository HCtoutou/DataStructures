## 链表

### 定义：

链表由一系列不必在内存中相连的结构组成。每一个结构均含有表元素和指向包含该元素后继元的结构的指针。我们称之为Next指针。最后一个单元的Next指针指向NULL；该值由C定义并且不能与其他指针混淆。ANSI C规定NULL为零。

### 哑元：

上面的描述实际上足以使每一部分都能正常工作，但还是有几处地方可能会出问题。

- 第一，并不存在从所给定义出发在表的起始段插入元素的真正线性的方法。

- 第二，从表的起始段实行删除是一个特殊情况，因为改变了表的起始段，编程中的疏忽将会造成表的丢失。

- 第三个问题涉及一般的删除。虽然上述指针的移动很简单，但是删除算法要求我们记住被删除元素前面的表元。

  事实上，稍微做一个简单的变化就能够解决上述三个问题。我们可以留出一个标志节点，有时候称之为表头（header）或者哑节点（dummy node）。

### 链表基本功能实现：

**创建**

```c
Position Creat(int n) {
	Position head, node, end;
	head = malloc(sizeof(struct Node));
	end = head;
	printf("%d\n", head->Element);
	for (int i = 0; i < n; i++) {
		node = malloc(sizeof(struct Node));
		node->Element = i;
		end->Next = node;
		end = node;
	}
	end->Next = NULL;
	return head;
}
```



**打印**

```c
void Show(List L) {
	Position node;
	node = L->Next;
	while (node != NULL) {
		printf("%d\n", node->Element);
		node = node->Next;
	}
}
```



**查找**

```c
Position Find(int X, List L) {//查找
	Position P;
	P = L->Next;
	while (P != NULL && P->Element != X)
		P = P->Next;
	return P;
}
```



**插入**

```c
void Insert(int X, List L, Position P) {//插入操作（插入到P的后面）
	Position TmpCell;
	TmpCell = malloc(sizeof(struct Node));
	if (TmpCell == NULL)//节点申请失败
		FatalError("Out of space!!!");
	TmpCell->Element = X;
	TmpCell->Next = P->Next;
	P->Next = TmpCell;
}
```



**删除**

```c
void Delete(int X, List L) {
	Position P, TmpCell;
	P = FindPrevious(X, L);
	if (!IsLast(P, L)) {
		TmpCell = P->Next;
		P->Next = TmpCell->Next;
		free(TmpCell);
	}
}
```



### 双链表

在链表的基础上再增加一个域，使它包含指向前一个单元的指针即可

### 循环链表

让最后的单元反过来直指第一个单元。它可以有表头也可以没有，并且还可以是双向链表。



## 栈（后进先出LIFO）

### 定义

栈是限制插入和删除只能再一个位置上进行的表，该位置是表的末端，叫做栈的顶（top）。

对栈的基本操作有Push（进栈）和Pop（出栈），前者相当于插入，后者则是删除最后插入的元素。

栈顶元素是唯一可见元素。
### 栈的链表实现
**创建一个空栈**
```c
Stack CreatStack(void) {//创建一个空栈
	Stack S;
	S = malloc(sizeof(struct Node));
	if (S == NULL)
		exit(0);
	S->Next = NULL;
	MakeEmpty(S);
	return S;
}
void MakeEmpty(Stack S) {//将栈置空
	if (S == NULL)
		printf("Must use CreatStack first");
	else
		while (!IsEmpty(S))
			Pop(S);
}
```
**入栈**
```c
void Push(int X, Stack S) {//入栈操作
	PtrToNode TmpCell;
	TmpCell = malloc(sizeof(struct Node));
	if (TmpCell == NULL)
		exit(0);
	else {
		TmpCell->Element = X;
		TmpCell->Next = S->Next;
		S->Next = TmpCell;
	}
}
```
**出栈**
```c
void Pop(Stack S) {//出栈操作
	PtrToNode FirstCell;
	if (IsEmpty(S))
		printf("Empty Stack");
	else {
		FirstCell = S->Next;
		S->Next = S->Next->Next;
		free(FirstCell);
	}
}
```
### 应用
**平衡符号**
做一个空栈。读入字符直到文件尾。如果一个字符是一个开放符号，则将其推入栈中。如果字符是一个封闭符号，则当栈空时报错；否则，将元素弹出。如果弹出的符号不是对应的开放符号，则报错。在文件尾，如果栈非空则报错。
