- 存在几种容易的算法以O(N^2)排序，如插入排序。

- 有一种算法叫做希尔排序（Shellsort），它的编程非常简单，以o(N^2)运行，并在实践中很有效。

- 有一些稍微复杂的O(N log N)的排序算法。

- 任何通用的排序算法均需要Ω(N log N)次比较

### 插入排序

插入排序由N-1趟排序组成。对于P=1趟到P=N-1趟，插入排序保证从位置0到位置P-1上的元素是已经排过序的。

在第P趟，我们将位置P上的元素向左移动到它在前P+1个元素中的正确位置上。

```c
void InsertionSort(int A[],int N){
    int j,p;
    int Type,Tmp;
    for(P=1;P<N;P++){
        Tmp=A[P];
        for(j=P;j>0&&A[j-1]>Tmp;j--)
            A[j]=A[j-1];//实现数据移动但没有明显使用交换。将位置P上的元素存于Tmp中，而
        A[j]=Tmp;		//（在位置P之前）所有更大的元素都向右移动一个位置。然后将Tmp置
    }					//于正确的位置上
}
```



#### 插入排序分析

由于嵌套循环每趟花费N次迭代，因此插入排序为O（N^2）,而且这个界是精确的，因为以反序输入可以达到该界。

如果输入数据已经预先排序，那么运行时间为O（N），因为内层for循环的检测总是立即判定不成立而终止。事实上，如果输入几乎已排序，那么插入排序将运行得很快。由于这种变化差别很大，因此值得我们去分析该算法平均情形得行为。

#### 一些简单排序算法的下界

插入排序的交换次数正好等于这个待排序数组中的逆序数。

- 定理7.1：N个互异数的数组的平均逆序数是N（N-1）/4。
- 定理7.2：通过交换相邻元素进行排序的任何算法平均需要Ω（N^2）时间。



### 希尔排序

希尔排序是冲破二次时间屏障的第一批算法之一。它通过比较相距一定间隔的元素来工作，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。由于这个原因，希尔排序有时也叫做缩小增量排序

```c
void Shellsort(int A[],int N){
    int i,j,Increment;
    int Tmp;
    
    for(Increment=N/2;Increment>0;Increment/=2)
        for(i=Increment;i<N;i++){
            Tmp=A[i];
            for(j=i;j>=Increment;j-=Increment)
                if(Tmp<A[j-Increment])
                    A[j]=A[j-Increment];
            else
                break;
            A[j]=Tmp;
        }
}
```

#### 希尔排序的最坏情形分析

虽然希尔排序编程简单，但是，其运行时间的分析则完全是另外一回事。希尔排序的运行时间依赖于增量序列的选择，而证明可能相当复杂。希尔排序的平均情形分析，除最平凡的一些增量序列外，是一个长期未解决的问题。

- 定理7.3：使用希尔增量时希尔排序的最坏情形运行时间为O(N^2)

- 定理7.4：使用Hibbard增量的希尔排序的最坏情形运行时间为O(N^(3/2))

### 堆排序

  优先队列可以用于花费O(N logN)时间的排序。基于该想法的算法叫作堆排序。

建立二叉堆花费O(N)的时间。然后我们执行N次DeleteMin操作。按照顺序，最小的元素先离开该堆。通过将这些元素记录到第二个数组然后再将数组拷贝回来，我们得到N个元素的排序。由于DeleteMin花费O(logN)时间，因此总的运行时间是O(NlogN)。

该算法的主要问题在于它使用了一个附加的数组。因此，存储需求增加一倍。避免使用第二个数组的聪明做法是利用这样的事实：在每次DeleteMin之后，堆缩小了1。因此位于堆中最后的单元可以用来存放刚刚删去的元素。使用这种策略，在最后一次DeleteMin后，该数组将以递减的顺序包含这些元素。如果想要这些元素排成更典型的递增顺序，那么可以改变序的特性使得父亲的关键字的值大于儿子的关键字的值。这样就得到max堆。

#### 堆排序分析

堆排序是一个非常稳定的算法：它平均使用的比较只比最坏情形界指出的略少。

- 定理7.5：对N个互异项的随机排列进行堆排序，所用的平均比较次数为2NlogN - O(N log log N).

### 归并排序

归并排序以O(NlogN)最坏情形运行时间运行，而所使用的比较次数几乎是最优的。它是递归算法一个很好的实例。

这个算法中基本的操作是合并两个已排序的表。因为这两个表是已排序的，所以若将输出放到第三个表中，则该算法可以通过对输入数据一趟排序来完成。基本的合并算法是取两个输入数组A和B，一个输出数组C，以及三个计数器Aptr，Bptr，Cptr，它们初始置于对应数组的开端。A[Aptr]，B[Bptr]中的较小者被拷贝到C中的下一个位置，相关的计数器向前推进一步。当两个输入表有一个用完的时候，则将另一个表中的剩余部分拷贝到C中。

#### 归并排序的分析

虽然归并排序的运行时间是O(NlogN)，但是它很难用于主存排序，主要问题在于合并两个排序的表需要线性符加内存，在整个算法中还要花费将数据拷贝到临时数组再拷贝回来这样一些附加工作，其结果是严重放慢了排序的速度。这种拷贝可以通过在递归交替层次时审慎的转换A和TmpArray的角色来得到避免。

### 快速排序

快速排序是在实践中最快的已知排序算法，它的平均运行时间是O(NlogN)。该算法之所以特别快，主要是由于非常精炼且高度优化的内部循环。它的最坏情形的性能为O(N^2)，但稍加努力就可避免这种情形。

像归并排序一样，快速排序也是一种分治的递归算法。将数组S排序的基本算法由下列简单的四步组成：

1.如果S中元素个数是0或1，则返回。

2.取S中任意元素v，称之为枢纽元。

3.将S-{v}（S中其余元素）分成两个不相交的集合：S1={x∈S-{v}|x≤v}和S2={x∈S-{v}|x≥v}。

4.返回{quicksort（S1）后，继而v，继而quicksort（S2）}.

由于对那些等于枢纽元的元素的处理，第三步分割的描述不是唯一的，因此这就成了一个设计上的决策。

#### 选取枢纽元

##### 一种错误的做法

没有经过充分考虑的常见选择是将第一个元素用作枢纽元。如果输入是随机的，那么这是可以接受的，但是如果输入是预排序的或是反序的，那么这样的枢纽元就产生一个劣质的分割，因为所有的元素不是都被划入S1,就是都被划入S2.

##### 一种安全的做法

一种安全的方针是随机选取枢纽元。但是随机数的生成是昂贵的，根本减少不了算法其余部分的平均运行时间。

##### 三数中值分割法

一组N个数的中值是N/2（向上取整）个最大的数。枢纽元的最好选择是数组的中值。不幸的是这很难算出，且会明显减慢快速排序的速度。这样的中值的估计量可以通过随机选取三个元素并用它们的中值作为枢纽元而得到，事实上，随机性并没有多大的帮助，因此一般的做法是使用左端，右端和中心位置上的三个元素的中值作为枢纽元。显然使用三数中值分割法消除了预排序输入的坏情形（在这种情形下，这些分割都是一样的），并且减少了快速排序大约百分之五的运行时间。

#### 分割策略

第一步是通过将枢纽元与最后的元素交换使得枢纽元离开要被分割的数据段。i从第一个元素开始而j从倒数第二个元素开始。

#### 小数组

对于很小的数组(N≤20)，快速排序不如插入排序好，不仅如此，因为快速排序是递归的，所以这样的情形还经常发生。通常的解决方法是对于小的数组不是递归的使用快速排序，而是使用诸如插入排序这样的对于小数组有效的排序算法。使用这种策略实际上可以节约大约百分之15的运行时间。



### 不相交集ADT

- 讨论如何能够以最少的编程代价实现。
- 通过两个简单的观察极大的增加它的速度
- 分析一种快速实现方法的运行时间
- 介绍一个简单的应用



#### 按大小求并（总让较小的树成为较大的树的子树）

```c
void SetUnion(DisjSet S, SetType Root1, SetType Root2) {
	if (S[Root2] < S[Root1])
		S[Root1] = Root2;
	else {
		if (S[Root1] == S[Root2])
			S[Root1]--;
		S[Root2] = Root1;
	}
```

#### 路径压缩

路径压缩在一次Find操作期间执行，而与用来执行Union的方法无关。设操作为Find（X），此时路径压缩的效果是，从X到根的路径上的每一个节点都使它的父节点变成根。路径压缩的实施在于使用额外的两次指针移动

```c
SetType Find(ElemenType X, DisjSet S) {
	if (S[X] <= 0)
		return X;
	else
		return S[X] = Find(S[X], X);
}
```

路劲压缩是自调整的最早形式之一，我们已经在别的一些地方（伸展树，斜堆）见到过。它的使用非常有趣，特别是从理论的观点来看，因为它是算法简单但最坏情形分析却并不这么简单的第一批例子之一。